{"category":"Ultrasonic","color":"#002fa6","blocks":["__Ultrasonic_Ultrasonic_Setup","__Ultrasonic_pin_setup","__Ultrasonic_distance_cm","__Ultrasonic_distance_mm"],"jscode":"// Block __Ultrasonic_Ultrasonic_Setup\nvar __Ultrasonic_Ultrasonic_Setup_json = {\n    \"previousStatement\": null,\n    \"nextStatement\": null,\n    \"message0\": \"%1\",\n    \"args0\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"Ultrasonic Setup\"\n        }\n    ],\n    \"colour\": \"#002fa6\"\n};\n\nwindow['Blockly'].Blocks['__Ultrasonic_Ultrasonic_Setup'] = {\n    init: function() {\n        this.jsonInit(__Ultrasonic_Ultrasonic_Setup_json);\n    }\n};\n\nwindow['Blockly'].Python['__Ultrasonic_Ultrasonic_Setup'] = function(block) {\n        return `import time\nfrom uos import uname\nfrom machine import Pin\n\ntry:\n    from machine import time_pulse_us\nexcept:\n    from pycom import pulses_get\n\n#__author__ = 'Roberto Sánchez'\n#__license__= \"Apache License 2.0. https://www.apache.org/licenses/LICENSE-2.0\"\n#__author-update__ = \"Mauro Riva\"\n\nclass HCSR04:\n  \n    # echo_timeout_us is based in chip range limit (400cm)\n    def __init__(self, trigger_pin, echo_pin, echo_timeout_us=500*2*30):\n        self.echo_timeout_us = echo_timeout_us\n        # Init trigger pin (out)\n        self.trigger = Pin(trigger_pin, mode=Pin.OUT)\n        self.trigger.value(0)\n        # Init echo pin (in)\n        if (uname().sysname == 'WiPy'):\n            self.echo = Pin(echo_pin, mode=Pin.OPEN_DRAIN)\n        else:\n            self.echo = Pin(echo_pin, mode=Pin.IN)\n\n    def _send_pulse_and_wait(self):\n        self.trigger.value(0) # Stabilize the sensor\n        time.sleep_us(5)\n        self.trigger.value(1)\n        # Send a 10us pulse.\n        time.sleep_us(10)\n        self.trigger.value(0)\n        try:\n            if (uname().sysname == 'WiPy'):\n                pulse_list = pulses_get(self.echo, self.echo_timeout_us)\n                if(len(pulse_list) == 0):\n                    pulse_time = -1\n                else:\n                    pulse_time = pulse_list[0][1]\n            else:\n                pulse_time = time_pulse_us(self.echo, 1, self.echo_timeout_us)\n\n            return pulse_time\n        except OSError as ex:\n            if ex.args[0] == 110: # 110 = ETIMEDOUT\n                raise OSError('Out of range')\n            raise ex\n\n    def distance_mm(self):\n        pulse_time = self._send_pulse_and_wait()\n\n        # To calculate the distance we get the pulse_time and divide it by 2\n        # (the pulse walk the distance twice) and by 29.1 becasue\n        # the sound speed on air (343.2 m/s), that It's equivalent to\n        # 0.34320 mm/us that is 1mm each 2.91us\n        # pulse_time // 2 // 2.91 -> pulse_time // 5.82 -> pulse_time * 100 // 582\n        mm = pulse_time * 100 // 582\n        return mm\n\n    def distance_cm(self):\n        pulse_time = self._send_pulse_and_wait()\n\n        # To calculate the distance we get the pulse_time and divide it by 2\n        # (the pulse walk the distance twice) and by 29.1 becasue\n        # the sound speed on air (343.2 m/s), that It's equivalent to\n        # 0.034320 cm/us that is 1cm each 29.1us\n        cms = (pulse_time / 2) / 29.1\n        return cms` + \"\\n\";\n};\n\n// Block __Ultrasonic_pin_setup\nvar __Ultrasonic_pin_setup_json = {\n    \"previousStatement\": null,\n    \"nextStatement\": null,\n    \"message0\": \"%1\",\n    \"args0\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"Pin Setup\"\n        }\n    ],\n    \"message1\": \"%1 %2\",\n    \"args1\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"triger_pin\"\n        },\n        {\n            \"type\": \"field_number\",\n            \"value\": 0,\n            \"name\": \"triger_pin\"\n        }\n    ],\n    \"message2\": \"%1 %2\",\n    \"args2\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"echo_pin\"\n        },\n        {\n            \"type\": \"field_number\",\n            \"value\": 0,\n            \"name\": \"echo_pin\"\n        }\n    ],\n    \"colour\": \"#002fa6\"\n};\n\nwindow['Blockly'].Blocks['__Ultrasonic_pin_setup'] = {\n    init: function() {\n        this.jsonInit(__Ultrasonic_pin_setup_json);\n    }\n};\n\nwindow['Blockly'].Python['__Ultrasonic_pin_setup'] = function(block) {\n    var triger_pin = block.getFieldValue('triger_pin');\nvar echo_pin = block.getFieldValue('echo_pin');\n    return `sensor = HCSR04(trigger_pin=${triger_pin}, echo_pin=${echo_pin}, echo_timeout_us=10000)` + \"\\n\";\n};\n\n// Block __Ultrasonic_distance_cm\nvar __Ultrasonic_distance_cm_json = {\n    \"output\": null,\n    \"message0\": \"%1\",\n    \"args0\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"distance_cm\"\n        }\n    ],\n    \"colour\": \"#002fa6\"\n};\n\nwindow['Blockly'].Blocks['__Ultrasonic_distance_cm'] = {\n    init: function() {\n        this.jsonInit(__Ultrasonic_distance_cm_json);\n    }\n};\n\nwindow['Blockly'].Python['__Ultrasonic_distance_cm'] = function(block) {\n        return [`sensor.distance_cm()`, Blockly.Python.ORDER_CONDITIONAL]\n};\n\n// Block __Ultrasonic_distance_mm\nvar __Ultrasonic_distance_mm_json = {\n    \"output\": null,\n    \"message0\": \"%1\",\n    \"args0\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"distance_mm\"\n        }\n    ],\n    \"colour\": \"#002fa6\"\n};\n\nwindow['Blockly'].Blocks['__Ultrasonic_distance_mm'] = {\n    init: function() {\n        this.jsonInit(__Ultrasonic_distance_mm_json);\n    }\n};\n\nwindow['Blockly'].Python['__Ultrasonic_distance_mm'] = function(block) {\n        return [`sensor.distance_mm()`, Blockly.Python.ORDER_CONDITIONAL]\n};\n\n","code":{"Ultrasonic_Setup":["window['Blockly'].Python['__Ultrasonic_Ultrasonic_Setup'] = function(block) {\n        return `import time\nfrom uos import uname\nfrom machine import Pin\n\ntry:\n    from machine import time_pulse_us\nexcept:\n    from pycom import pulses_get\n\n#__author__ = 'Roberto Sánchez'\n#__license__= \"Apache License 2.0. https://www.apache.org/licenses/LICENSE-2.0\"\n#__author-update__ = \"Mauro Riva\"\n\nclass HCSR04:\n  \n    # echo_timeout_us is based in chip range limit (400cm)\n    def __init__(self, trigger_pin, echo_pin, echo_timeout_us=500*2*30):\n        self.echo_timeout_us = echo_timeout_us\n        # Init trigger pin (out)\n        self.trigger = Pin(trigger_pin, mode=Pin.OUT)\n        self.trigger.value(0)\n        # Init echo pin (in)\n        if (uname().sysname == 'WiPy'):\n            self.echo = Pin(echo_pin, mode=Pin.OPEN_DRAIN)\n        else:\n            self.echo = Pin(echo_pin, mode=Pin.IN)\n\n    def _send_pulse_and_wait(self):\n        self.trigger.value(0) # Stabilize the sensor\n        time.sleep_us(5)\n        self.trigger.value(1)\n        # Send a 10us pulse.\n        time.sleep_us(10)\n        self.trigger.value(0)\n        try:\n            if (uname().sysname == 'WiPy'):\n                pulse_list = pulses_get(self.echo, self.echo_timeout_us)\n                if(len(pulse_list) == 0):\n                    pulse_time = -1\n                else:\n                    pulse_time = pulse_list[0][1]\n            else:\n                pulse_time = time_pulse_us(self.echo, 1, self.echo_timeout_us)\n\n            return pulse_time\n        except OSError as ex:\n            if ex.args[0] == 110: # 110 = ETIMEDOUT\n                raise OSError('Out of range')\n            raise ex\n\n    def distance_mm(self):\n        pulse_time = self._send_pulse_and_wait()\n\n        # To calculate the distance we get the pulse_time and divide it by 2\n        # (the pulse walk the distance twice) and by 29.1 becasue\n        # the sound speed on air (343.2 m/s), that It's equivalent to\n        # 0.34320 mm/us that is 1mm each 2.91us\n        # pulse_time // 2 // 2.91 -> pulse_time // 5.82 -> pulse_time * 100 // 582\n        mm = pulse_time * 100 // 582\n        return mm\n\n    def distance_cm(self):\n        pulse_time = self._send_pulse_and_wait()\n\n        # To calculate the distance we get the pulse_time and divide it by 2\n        # (the pulse walk the distance twice) and by 29.1 becasue\n        # the sound speed on air (343.2 m/s), that It's equivalent to\n        # 0.034320 cm/us that is 1cm each 29.1us\n        cms = (pulse_time / 2) / 29.1\n        return cms` + \"\\n\";\n};\n\n","import time\nfrom uos import uname\nfrom machine import Pin\n\ntry:\n    from machine import time_pulse_us\nexcept:\n    from pycom import pulses_get\n\n#__author__ = 'Roberto Sánchez'\n#__license__= \"Apache License 2.0. https://www.apache.org/licenses/LICENSE-2.0\"\n#__author-update__ = \"Mauro Riva\"\n\nclass HCSR04:\n  \n    # echo_timeout_us is based in chip range limit (400cm)\n    def __init__(self, trigger_pin, echo_pin, echo_timeout_us=500*2*30):\n        self.echo_timeout_us = echo_timeout_us\n        # Init trigger pin (out)\n        self.trigger = Pin(trigger_pin, mode=Pin.OUT)\n        self.trigger.value(0)\n        # Init echo pin (in)\n        if (uname().sysname == 'WiPy'):\n            self.echo = Pin(echo_pin, mode=Pin.OPEN_DRAIN)\n        else:\n            self.echo = Pin(echo_pin, mode=Pin.IN)\n\n    def _send_pulse_and_wait(self):\n        self.trigger.value(0) # Stabilize the sensor\n        time.sleep_us(5)\n        self.trigger.value(1)\n        # Send a 10us pulse.\n        time.sleep_us(10)\n        self.trigger.value(0)\n        try:\n            if (uname().sysname == 'WiPy'):\n                pulse_list = pulses_get(self.echo, self.echo_timeout_us)\n                if(len(pulse_list) == 0):\n                    pulse_time = -1\n                else:\n                    pulse_time = pulse_list[0][1]\n            else:\n                pulse_time = time_pulse_us(self.echo, 1, self.echo_timeout_us)\n\n            return pulse_time\n        except OSError as ex:\n            if ex.args[0] == 110: # 110 = ETIMEDOUT\n                raise OSError('Out of range')\n            raise ex\n\n    def distance_mm(self):\n        pulse_time = self._send_pulse_and_wait()\n\n        # To calculate the distance we get the pulse_time and divide it by 2\n        # (the pulse walk the distance twice) and by 29.1 becasue\n        # the sound speed on air (343.2 m/s), that It's equivalent to\n        # 0.34320 mm/us that is 1mm each 2.91us\n        # pulse_time // 2 // 2.91 -> pulse_time // 5.82 -> pulse_time * 100 // 582\n        mm = pulse_time * 100 // 582\n        return mm\n\n    def distance_cm(self):\n        pulse_time = self._send_pulse_and_wait()\n\n        # To calculate the distance we get the pulse_time and divide it by 2\n        # (the pulse walk the distance twice) and by 29.1 becasue\n        # the sound speed on air (343.2 m/s), that It's equivalent to\n        # 0.034320 cm/us that is 1cm each 29.1us\n        cms = (pulse_time / 2) / 29.1\n        return cms"],"pin_setup":["window['Blockly'].Python['__Ultrasonic_pin_setup'] = function(block) {\n    var triger_pin = block.getFieldValue('triger_pin');\nvar echo_pin = block.getFieldValue('echo_pin');\n    return `sensor = HCSR04(trigger_pin=${triger_pin}, echo_pin=${echo_pin}, echo_timeout_us=10000)` + \"\\n\";\n};\n\n","sensor = HCSR04(trigger_pin=${triger_pin}, echo_pin=${echo_pin}, echo_timeout_us=10000)"],"distance_cm":["window['Blockly'].Python['__Ultrasonic_distance_cm'] = function(block) {\n        return [`sensor.distance_cm()`, Blockly.Python.ORDER_CONDITIONAL]\n};\n\n","sensor.distance_cm()"],"distance_mm":["window['Blockly'].Python['__Ultrasonic_distance_mm'] = function(block) {\n        return [`sensor.distance_mm()`, Blockly.Python.ORDER_CONDITIONAL]\n};\n\n","sensor.distance_mm()"]}}